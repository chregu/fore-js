import e from"axios";import{v4 as t}from"uuid";import r from"humps";class s{constructor({apiToken:t,apiUrl:s="https://foresight-gateway.foreai.co",uiUrl:n="https://foresight.foreai.co",maxEntriesBeforeAutoFlush:i=10,axiosInstance:o}){this.apiToken=t,this.apiUrl=s,this.uiUrl=n,this.maxEntriesBeforeAutoFlush=i,this.axiosInstance=o||e.create(),this.timeoutSeconds=60,this.logEntries=[],this.logging=console,this.logging.info("Foresight client initialized"),this.axiosInstance.interceptors.response.use((e=>{const t=e.config.url;if(t&&["/api/eval/run/queries"].some((e=>t.includes(e))))return e;if(e.data)try{e.data=r.camelizeKeys(e.data)}catch(e){}return e}))}async _makeRequest({method:e,endpoint:t,params:r=null,inputJson:s=null}){try{return(await this.axiosInstance.request({method:e,url:`${this.apiUrl}${t}`,headers:{Authorization:`Bearer ${this.apiToken}`},params:r,data:s,timeout:1e3*this.timeoutSeconds})).data}catch(e){throw e.response&&this.logging.error("api:error:",`${e.response.status} : ${e.response.statusText}`),e}}async createSimpleEvalset({evalsetId:e,queries:r,referenceAnswers:s=null}){try{if(null==e||null==r)throw new Error("evalsetId and queries are required.");if(s&&r.length!==s.length)throw new Error("Number of queries and references must match.");const n={evalset_id:e,evalset_entries:r.map(((e,r)=>({query:e,reference_answer:s?s[r]:null,entry_id:t()})))},i=await this._makeRequest({method:"post",endpoint:"/api/eval/set",inputJson:n});return this.logging.info(`Eval set with evalsetId ${e} created.`),i}catch(e){const t=e.message;throw this.logging.error("createSimpleEvalset:error:",t),new Error(t)}}async getEvalset({evalsetId:e}){try{return await this._makeRequest({method:"get",endpoint:"/api/eval/set",params:{evalset_id:e}})}catch(e){const t=e.message;throw this.logging.error("getEvalset:error:",t),new Error(t)}}async getEvalrunQueries({experimentId:e}){try{return await this._makeRequest({method:"get",endpoint:"/api/eval/run/queries",params:{experiment_id:e}})}catch(e){const t=e.message;throw this.logging.error("getEvalrunQueries:error:",t),new Error(t)}}async createEvalrun({runConfig:e}){try{const t=await this._makeRequest({method:"post",endpoint:"/api/eval/run",inputJson:{evalset_id:e.evalsetId,experiment_id:e.experimentId,metrics:e.metrics}});return this.logging.info(`Eval run with experimentId ${e.experimentId} created.`),t}catch(e){const t=e.message;throw this.logging.error("createEvalrun:error:",t),new Error(t)}}async generateAnswersAndRunEval({generateFn:e,runConfig:t}){try{await this.createEvalrun({runConfig:t});const r=t.experimentId,s=await this.getEvalrunQueries({experimentId:r}),n={};for(const[t,r]of Object.entries(s)){const{generatedResponse:s,contexts:i}=e(r);n[t]={generated_response:s,contexts:i}}const i={experiment_id:r,entry_id_to_inference_output:n},o=await this._makeRequest({method:"put",endpoint:"/api/eval/run/entries",inputJson:i});return this.logging.info("Eval run successful. Visit %s to view results.",this.uiUrl),o}catch(e){const t=e.message;throw this.logging.error("generateAnswersAndRunEval:error:",t),new Error(t)}}async flush(){try{if(0===this.logEntries.length)return void this.logging.info("No log entries to flush.");const e={log_entries:this.logEntries},t=await this._makeRequest({method:"put",endpoint:"/api/eval/log",inputJson:e});return this.logging.log("Log entries flushed successfully. Visit %s to view results.",this.uiUrl),this.logEntries=[],t}catch(e){const t=e.message;throw this.logging.error("flush:error:",t),new Error(t)}}async log({query:e,response:t,contexts:r}){try{const s={query:e,inference_output:{generated_response:t,contexts:r}};this.logEntries.push(s),this.logEntries.length>=this.maxEntriesBeforeAutoFlush&&await this.flush()}catch(e){const t=e.message;throw this.logging.error("log:error:",t),new Error(t)}}async getEvalrunDetails({experimentId:e,sortBy:t="input.query",limit:r=100}){try{const s={experiment_id:e};return null!==r&&null!==t&&(s.sort_field_name=t,s.limit=r.toString()),await this._makeRequest({method:"get",endpoint:"/api/eval/run/details",params:s})}catch(e){const t=e.message;throw this.logging.error("getEvalrunDetails:error:",t),new Error(t)}}}const n={GROUNDEDNESS:"GROUNDEDNESS",SIMILARITY:"SIMILARITY"};export{s as Foresight,n as MetricType};
